## 我的项目介绍
### 框架
1. apistellar: 这个一个基于apistar的异步框架，其功能完善易用，使用广泛。细节请参见github。
2. structure-spider: 这一个基于scrapy的结构化爬虫，这个项目的优势在于抓取结构复杂的嵌套信息。细节请参见github。
### 工具
1. pyaop: 一个非常有用的面向切面编程的基础包，在设计底层架构时非常有用，它的实现非常简单，只有一个文件不到百行代码。它使用了代理模式，其可代理一个对象，并自由地为其做生意方法调用前后增加切面，来实现各种调用效果。这个包兼容python全版本。
2. pytest-apistellar: 这个包最初是作为apistellar的插件存在的，其后来被设计成适用于有mock需求的所有单元测试编写场景。它的主要亮点是支持多作用域，级连mock，绝大多数情况下每次mock只需要一个装饰器就能完成，此外，它还能用来测试apistellar的接口，原理是使用子线程启用一个server并返回其port用来在测试方法中验证响应信息。同时它对异步程序单元测试的编写非常友好。
3. proxy-factory: 一个代理工厂程序，可自动获取网上的免费代理，并验证其有效性，这个项目完成于两年前，后来没有再维护，因此它自带的代理网站抓取规则可能已失效。但它的各个组件完全解耦，在稍微调整抓取规则后可以快速投入生产中使用。
4. translate_html: 这是一个翻译程序，其通过爬虫技术实现了自动从各大翻译网站获取翻译结果的功能。这个项目同样完成于两年前，后面没有再维护，它实现的翻译网站可能由于规则改变而失效，但它的各个组件完全解耦，在稍微调整抓取规则后可快速投入生产中使用。
6. dictionary_walker: 一个可以遍历目录的程序，适合遍历超多的文件。可断点续遍。
5. toolkit：这是一个工具包，其中包含了我工作以来大部分的通用积累，有些工具类、方法目前来说还是非常有用的，如：
    - cache_property: 类似于property，不过使用该装饰器后，该属性被缓存了一下来，只会计算一次，适合幂等方法使用。
    - cache_for: 类似于cache_property，不过其可传入一个整型来控制缓存时间。
    - cache_method: cache_property和cache_for都是基于property实现的，其用法仅限于将不存在参数的方法转换成属性，但有时我们可能还需要缓存多参数方法的调用，cache_method可用于缓存方法不同实参调用的结果，并持续一段时间。
    - cache_method_for_update: 其与cache_method的区别在于，这个方法会等当前对象的updated被置为true时重新更新缓存。这个装饰非常有用，我们可以实现一个updated property，用来控制什么时候该更新缓存了。
    - load: 这个函数可以用来返回字符串表示的模块、函数、类、及类的属性等。
    - classproperty: property只能用于实例方法到实例属性的转换，使用classproperty来支持类方法到类属性的转换，其经常用于懒加载。
    - cache_classproperty: 使用该装饰器后，该属性被缓存了下来，只会计算一次，适合幂等类方法使用。
    - global_cache_classproperty: 与cache_classproperty的区别在于子类和父类共用同一份缓存。
    - async_context: contextlib中定义了一个有用的工具contextmanager可以将生成器转换成上下文管理器，但是只支持同步生成器转换成同步上下文管理器，async_context.contextmanager支持任意转换，即同步转同步，同步转异步，异步转异步，异步转同步的模式，在异步编程时有非常高的使用价值。
    - monitors: 里面定义了一些基类如：Service,适合在编写可执行脚本时作为通用基类使用。
    - markdown_helper: 用来将整个markdown文件夹递归的渲染成html。
    - processor: 用来监控管理一段业务逻辑的执行进度。
    - settings: 配置模块。
    - consoler: 继承之后可以切入到正在运行的程序内部，开启一个交互式命令，用于调试。
    - redis_tool: redis的一些通用实现，如分布式锁。
    - package_control: 用来构建python包的工具。
    - ....
  
### 玩具
1. custom_redis: 这是一个redis的简单实现，是我学习元编程时的作品，其存在的意义在于今后在我项目中使用元编程遇到坑时可以快速翻阅其代码寻找解决方案。
2. async-downloader: 这是一个练手项目，其存在的意义在于让我可以知道所有的异步魔法方法如何使用，利于我快速回忆异步编程的基础知识，并投入生产开发。
3. coroutine: 这是一个协程的python全版本通用实现，其存在的意义在于当我忘记协程的实现时，可以快速翻阅其代码来回忆。